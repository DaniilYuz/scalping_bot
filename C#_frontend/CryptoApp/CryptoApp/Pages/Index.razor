@page "/"
@using System.Runtime.InteropServices
@using System.Text
@using CryptoApp.Interop
@using Microsoft.AspNetCore.Components.Authorization
@inject ILogger<Index> Logger
@implements IDisposable

<PageTitle>Dashboard</PageTitle>

<h2>📊 Dashboard</h2>

<div class="status-panel">
    <h4>
        Общий статус бота:
        <span class="@GetStatusClass()">
            @if (BotConnected)
            {
                <text>🔄 Подключено</text>
            }
            else
            {
                <text>🔌 Отключено</text>
            }
        </span>
    </h4>
    @if (!BotConnected)
    {
        <button class="btn btn-success" @onclick="StartBot" disabled="@isProcessing">
            @if (isProcessing)
            {
                <span class="spinner-border spinner-border-sm me-2"></span>
            }
            ▶️ Старт бота
        </button>
    }
    else
    {
        <button class="btn btn-danger" @onclick="StopBot" disabled="@isProcessing">⏹️ Стоп бота</button>
    }
</div>

@if (!string.IsNullOrEmpty(StatusMessage))
{
    <div class="alert alert-info mt-3">
        <strong>Статус:</strong> @StatusMessage
    </div>
}

@if (!string.IsNullOrEmpty(ErrorMessage))
{
    <div class="alert alert-danger mt-3">
        <strong>Ошибка:</strong> @ErrorMessage
    </div>
}

<hr />

<div class="coins-list">
    <h4>Активные монеты</h4>
    <ul>
        @foreach (var coin in ActiveCoins)
        {
            <li>@coin</li>
        }
    </ul>
</div>

<hr />

<div class="info-section">
    <h4>📈 Текущие данные</h4>
    <p><strong>Последний сигнал:</strong> @LastSignal</p>
    <p><strong>PnL:</strong> @PnL$</p>
    <p><strong>Сделок выполнено:</strong> @TradesCount</p>
    <p><strong>Аптайм:</strong> @Uptime</p>
</div>

@code {
    private bool BotConnected = false;
    private bool isProcessing = false;
    private List<string> ActiveCoins = new() { "BTCUSDT", "ETHUSDT" };
    private string LastSignal = "Нет данных";
    private double PnL = 0.0;
    private int TradesCount = 0;
    private string Uptime => (DateTime.Now - StartTime).ToString(@"hh\:mm\:ss");
    private DateTime StartTime = DateTime.Now;
    private IntPtr botHandle = IntPtr.Zero;
    private string StatusMessage = "";
    private string ErrorMessage = "";

    protected override void OnInitialized()
    {
        Logger.LogInformation("🚀 Dashboard инициализирован в {Time}", DateTime.Now);
        StatusMessage = "Dashboard загружен успешно";
        base.OnInitialized();
    }

    private async Task StartBot()
    {
        try
        {
            isProcessing = true;
            ErrorMessage = "";
            StatusMessage = "Запуск бота...";
            StateHasChanged();

            Logger.LogInformation("🔥 StartBot triggered at {Time}", DateTime.Now);

            // Использование Rust-библиотеки через обёртку Ruster
            var ruster = new Ruster();
            long result = ruster.RusterCall(10, 20); // Пример аргументов, подставьте нужные

            Logger.LogInformation("📊 RusterCall result: {Result}", result);

            if (result == 30)
            {
                BotConnected = true;
                StatusMessage = "Бот успешно запущен через Rust библиотеку";
                Logger.LogInformation("✅ Bot connected successfully");
            }
            else
            {
                BotConnected = false;
                StatusMessage = $"Неожиданный результат от Rust: {result}";
                Logger.LogWarning("⚠️ Unexpected result from Rust: {Result}", result);
            }
        }
        catch (Exception ex)
        {
            BotConnected = false;
            ErrorMessage = $"Ошибка при запуске бота: {ex.Message}";
            Logger.LogError(ex, "❌ Ошибка при запуске бота");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }


    private async Task StopBot()
    {
        try
        {
            isProcessing = true;
            StatusMessage = "Остановка бота...";
            StateHasChanged();

            Logger.LogInformation("🛑 StopBot triggered at {Time}", DateTime.Now);

            await Task.Delay(500);

            BotConnected = false;
            StatusMessage = "Бот остановлен";
            Logger.LogInformation("✅ Bot stopped successfully");
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Ошибка при остановке бота: {ex.Message}";
            Logger.LogError(ex, "❌ Ошибка при остановке бота");
        }
        finally
        {
            isProcessing = false;
            StateHasChanged();
        }
    }

    private string GetStatusClass() => BotConnected ? "text-success" : "text-danger";

    public void Dispose()
    {
        Logger.LogInformation("🧹 Dashboard disposed");
    }
}